name: VersionUpgrade

on:
  workflow_dispatch:
    inputs:
      versionTag:
        description: 'Bump Version (e.g., v1.0.0)'
        required: true
        type: string

env:
  RELEASE_BRANCH_PREFIX: release
  BASE_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
  LOG_PREFIX: "[VersionUpgrade][$(date -u +%Y-%m-%dT%H:%M:%SZ)]"

concurrency:
  group: release-${{ github.event.inputs.versionTag || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  bumpAndCreatePR:
    name: Bump Version and Create PR
    if: github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      releaseBranch: ${{ steps.createBranch.outputs.releaseBranch }}
      prNumber: ${{ steps.createPR.outputs.prNumber }}
      nextVersionTag: ${{ steps.validateTag.outputs.nextVersionTag }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate and Increment Version Tag
        id: validateTag
        run: |
          echo "${{ env.LOG_PREFIX }} Validating version tag: ${{ github.event.inputs.versionTag }}"
          VERSION_TAG="${{ github.event.inputs.versionTag }}"
          [[ "$VERSION_TAG" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]] || { echo "${{ env.LOG_PREFIX }} ::error::Invalid version tag format. Expected vX.Y.Z, got $VERSION_TAG"; exit 1; }
          VERSION_TAG="${VERSION_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_TAG"
          
          git fetch --tags
          
          MATCHING_TAGS=$(git tag | grep -E "^v$MAJOR\.$MINOR\.[0-9]+$" | sort -V)
          if [ -z "$MATCHING_TAGS" ]; then
            NEXT_VERSION_TAG="v$MAJOR.$MINOR.$PATCH"
          else
            HIGHEST_PATCH=$(echo "$MATCHING_TAGS" | tail -n 1 | cut -d'.' -f3)
            if [ "$HIGHEST_PATCH" -lt 9 ]; then
              NEXT_VERSION_TAG="v$MAJOR.$MINOR.$((HIGHEST_PATCH + 1))"
            elif [ "$MINOR" -lt 9 ]; then
              NEXT_VERSION_TAG="v$MAJOR.$((MINOR + 1)).0"
            else
              NEXT_VERSION_TAG="v$((MAJOR + 1)).0.0"
            fi
          fi
          
          MAX_ATTEMPTS=100
          attempt=0
          while git tag | grep -q "^$NEXT_VERSION_TAG$"; do
            attempt=$((attempt + 1))
            if [ "$attempt" -ge "$MAX_ATTEMPTS" ]; then
              echo "${{ env.LOG_PREFIX }} ::error::Exceeded maximum attempts to find a unique version tag"
              exit 1
            fi
            IFS='.' read -r _ MAJOR MINOR PATCH <<< "${NEXT_VERSION_TAG#v}"
            if [ "$PATCH" -lt 9 ]; then
              NEXT_VERSION_TAG="v$MAJOR.$MINOR.$((PATCH + 1))"
            elif [ "$MINOR" -lt 9 ]; then
              NEXT_VERSION_TAG="v$MAJOR.$((MINOR + 1)).0"
            else
              NEXT_VERSION_TAG="v$((MAJOR + 1)).0.0"
            fi
          done
          
          echo "${{ env.LOG_PREFIX }} Next version tag: $NEXT_VERSION_TAG"
          echo "nextVersionTag=$NEXT_VERSION_TAG" >> $GITHUB_OUTPUT
        shell: bash

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Bump Version and Create Branch
        id: createBranch
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          npm ci || { echo "${{ env.LOG_PREFIX }} ::error::Failed to install dependencies"; exit 1; }
          bumpVersion="${{ steps.validateTag.outputs.nextVersionTag }}"
          bumpVersionTag="${bumpVersion#v}"
          npm version "$bumpVersionTag" --no-git-tag-version || { echo "${{ env.LOG_PREFIX }} ::error::Failed to bump version"; exit 1; }
          
          git add package.json package-lock.json
          git commit -m "chore(release): bump npm version to ${{ steps.validateTag.outputs.nextVersionTag }}" || { echo "${{ env.LOG_PREFIX }} ::error::Failed to commit"; exit 1; }
          
          RELEASE_BRANCH="${{ env.RELEASE_BRANCH_PREFIX }}_${{ steps.validateTag.outputs.nextVersionTag }}"
          git checkout -b "$RELEASE_BRANCH" || { echo "${{ env.LOG_PREFIX }} ::error::Failed to create branch"; exit 1; }
          git push origin "$RELEASE_BRANCH" || { echo "${{ env.LOG_PREFIX }} ::error::Failed to push branch"; exit 1; }
          
          echo "releaseBranch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT
        shell: bash

      - name: Create Pull Request
        id: createPR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `feat: version upgrade to ${{ steps.validateTag.outputs.nextVersionTag }}`,
              body: `## Summary\nAutomated release for ${{ steps.validateTag.outputs.nextVersionTag }}\n\n- Version bumped to ${{ steps.validateTag.outputs.nextVersionTag }}`,
              head: `${{ steps.createBranch.outputs.releaseBranch }}`,
              base: '${{ env.BASE_BRANCH }}'
            });
            console.log(`[VersionUpgrade][${new Date().toISOString()}] Pull request created: #${pr.number}`);
            core.setOutput('prNumber', pr.number);

      - name: Clean Workspace
        if: always()
        run: rm -rf $GITHUB_WORKSPACE/*

  waitForApproval:
    name: Wait for PR Approval
    if: github.event_name == 'workflow_dispatch'
    needs: bumpAndCreatePR
    permissions:
      pull-requests: write
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Monitor PR Approval
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_TOKEN }}
          script: |
            const PR_NUMBER = ${{ needs.bumpAndCreatePR.outputs.prNumber }};
            for (let attempt = 1; attempt <= 120; attempt++) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: PR_NUMBER
              });
            
              if (pr.merged) return console.log(`[VersionUpgrade][${new Date().toISOString()}] PR #${PR_NUMBER} merged`);
              if (pr.state === 'closed' && !pr.merged) core.setFailed(`PR #${PR_NUMBER} closed without merging`);
            
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: PR_NUMBER
              });
            
              if (reviews.some(review => review.state === 'APPROVED')) return console.log(`[VersionUpgrade][${new Date().toISOString()}] PR #${PR_NUMBER} approved`);
            
              console.log(`[VersionUpgrade][${new Date().toISOString()}] Waiting 30s (Attempt ${attempt}/120)`);
              await new Promise(resolve => setTimeout(resolve, 30000));
            }
            core.setFailed(`PR #${PR_NUMBER} not approved within 60 minutes`);

  mergeAndTag:
    name: Merge PR and Create Tag
    if: github.event_name == 'workflow_dispatch'
    needs:
      - waitForApproval
      - bumpAndCreatePR
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout Base Branch
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - name: Merge Pull Request and Create Tag
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_TOKEN }}
          script: |
            const PR_NUMBER = ${{ needs.bumpAndCreatePR.outputs.prNumber }};
            const NEXT_VERSION_TAG = '${{ needs.bumpAndCreatePR.outputs.nextVersionTag }}';
            const log = (msg) => console.log(`[VersionUpgrade][${new Date().toISOString()}] ${msg}`);

            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: PR_NUMBER
            });

            if (pr.merged) {
              log(`PR #${PR_NUMBER} already merged`);
            } else if (pr.state === 'closed') {
              core.setFailed(`PR #${PR_NUMBER} closed without merging`);
              return;
            } else {
              // Check mergeability
              let mergeable = pr.mergeable;
              let mergeable_state = pr.mergeable_state;
              // Sometimes mergeable is null if GitHub hasn't calculated it yet
              if (mergeable === null) {
                log('Mergeable state is null, refetching...');
                for (let i = 0; i < 5; i++) {
                  await new Promise(r => setTimeout(r, 2000));
                  const { data: pr2 } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: PR_NUMBER
                  });
                  if (pr2.mergeable !== null) {
                    mergeable = pr2.mergeable;
                    mergeable_state = pr2.mergeable_state;
                    break;
                  }
                }
              }
              log(`mergeable: ${mergeable}, mergeable_state: ${mergeable_state}`);
              if (mergeable_state === 'dirty' || mergeable === false) {
                core.setFailed(`PR #${PR_NUMBER} cannot be merged automatically (merge conflicts). Please resolve conflicts manually.`);
                return;
              }
              // Try to merge the PR
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: PR_NUMBER,
                  merge_method: 'merge'
                });
                log(`PR #${PR_NUMBER} merged`);
              } catch (e) {
                core.setFailed(`Failed to merge PR #${PR_NUMBER}: ${e.message}`);
                return;
              }
            }

            // Get the latest commit SHA on the base branch
            const { data: branch } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: pr.base.ref
            });

            // Create a tag
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${NEXT_VERSION_TAG}`,
                sha: branch.commit.sha
              });
              log(`Tag ${NEXT_VERSION_TAG} created`);
            } catch (e) {
              if (e.status === 422 && e.message.includes('Reference already exists')) {
                log(`Tag ${NEXT_VERSION_TAG} already exists, skipping tag creation.`);
              } else {
                core.setFailed(`Failed to create tag: ${e.message}`);
                return;
              }
            }

            // Create a draft release
            try {
              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: NEXT_VERSION_TAG,
                name: `Black Duck Security Scan ${NEXT_VERSION_TAG}`,
                body: `Black Duck Security Scan ${NEXT_VERSION_TAG}`,
                draft: true,
                prerelease: false
              });
              log(`Draft Release created`);
            } catch (e) {
              if (e.status === 422 && e.message.includes('already_exists')) {
                log(`Draft release for tag ${NEXT_VERSION_TAG} already exists, skipping release creation.`);
              } else {
                core.setFailed(`Failed to create draft release: ${e.message}`);
                return;
              }
            }

      - name: Clean Workspace
        if: always()
        run: |
          rm -rf $GITHUB_WORKSPACE
          git push origin "${{ needs.bumpAndCreatePR.outputs.releaseBranch }}" || { echo "${PR_NUMBER} not approved"; exit 1; }